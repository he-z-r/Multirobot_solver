""" This script tries only using the TuLiP toolbox to solve a multirobot planning execution (MrPE) problem.
A predefined paths are given and a control policy is generated by this script
"""

# Import the packages that we need
from __future__ import print_function
import numpy as np
from tulip import spec
from tulip.transys import machines
from tulip import synth
import gr1_fragment

# Define the parameters & desired trajectories
num_robots = 2  # must be > 1
num_cells = 5
trajectories = [[1, 2, 3], [4, 2, 5]]

# Define the env_vars based on the params % trajectories
env_vars = set()
env_vars_list = []
visit_times_all = np.zeros(num_cells, dtype=int)
for r in range(1, num_robots + 1):
    env_vars |= {'init' + str(r)}
    env_vars_list.append([])
    visit_times = np.zeros(num_cells, dtype=int)
    for p in trajectories[r - 1]:
        visit_times[p - 1] += 1
        new_env_var = 's' + str(r) + 'a' + str(p) + 'a' + str(visit_times[p - 1])
        env_vars |= {new_env_var}
        env_vars_list[r - 1].append(new_env_var)
    visit_times_all = np.row_stack((visit_times_all, visit_times))
visit_times_all = np.delete(visit_times_all, 0, 0)

# Define the initial conditions
env_init = set()
for r in range(1, num_robots + 1):
    env_init |= {'init' + str(r)}

env_safe = set()
env_prog = set()
# Encode the constraint that each robot can only appear in one position
env_unique = set()
for r in range(1, num_robots + 1):
    new_env_unique = '( ' + 'init' + str(r) + ' ) <-> ( '
    for p in env_vars_list[r - 1]:
        new_env_unique += '!' + p + ' && '
    new_env_unique = new_env_unique[:-3] + ')'
    env_unique |= {new_env_unique}
for r in range(1, num_robots + 1):
    for i in range(len(env_vars_list[r - 1])):
        new_env_unique = '( ' + env_vars_list[r - 1][i] + ' ) <-> ( ' + '!' + 'init' + str(r)
        for j in range(len(env_vars_list[r - 1])):
            if j != i:
                new_env_unique += ' && !' + env_vars_list[r - 1][j]
        new_env_unique += ' )'
        env_unique |= {new_env_unique}
env_safe |= env_unique

# Encode the transition system relations
env_trans = set()
# First, from initial positions to the first cells
for r in range(1, num_robots + 1):
    env_trans |= {'( ' + 'init' + str(r) + ' && ' + 'go' + str(r) + ' ) -> X( ' + 'init' + str(r) + ' || ' +
                  env_vars_list[r - 1][0] + ' )'}
    env_trans |= {'( ' + 'init' + str(r) + ' && ' + '!go' + str(r) + ' ) -> X( ' + 'init' + str(r) + ' )'}
# Then, from cells to cells
for r in range(1, num_robots + 1):
    for i in range(len(env_vars_list[r - 1]) - 1):
        env_trans |= {'( ' + env_vars_list[r - 1][i] + ' && ' + 'go' + str(r) + ' ) -> X( ' + env_vars_list[r - 1][i]
                      + ' || ' + env_vars_list[r - 1][i + 1] + ' )'}
        env_trans |= {'( ' + env_vars_list[r - 1][i] + ' && ' + '!go' + str(r) + ' ) -> X( ' + env_vars_list[r - 1][i]
                      + ' )'}
env_safe |= env_trans

# Encode the constraint that every robot should reach its destination and stay
env_dest = set()
sys_dest_stop = set()
for r in range(1, num_robots + 1):
    env_dest |= {'( ' + env_vars_list[r - 1][-1] + ' ) -> X( ' + env_vars_list[r - 1][-1] + ' )'}
    sys_dest_stop |= {env_vars_list[r - 1][-1]}
env_safe |= env_dest

# Encode the constraint that each robot should either not go or eventually not in the current cell
env_go = set()
for r in range(1, num_robots + 1):
    env_go |= {'( !' + 'init' + str(r) + ' || ' + '!go' + str(r) + ' )'}
    for i in range(len(env_vars_list[r - 1]) - 1):
        env_go |= {'( !' + env_vars_list[r - 1][i] + ' || ' + '!go' + str(r) + ' )'}
env_prog |= env_go

# Define sys_vars
sys_vars = set()
for r in range(1, num_robots + 1):
    sys_vars |= {'go' + str(r)}

# Define initial command. Now assume each robot is stopped at the beginning
sys_init = set()
# for r in range(1, num_robots + 1):
#     sys_init |= {'!go' + str(r)}

sys_safe = set()
sys_prog = set()
'''
dest_stop_str = ''
for i in sys_dest_stop:
    dest_stop_str += i + ' && '
dest_stop_str = dest_stop_str[:-4]
spec_dest = gr1_fragment.stability_to_gr1(dest_stop_str, 'dest_aux')
sys_vars |= {'dest_aux'}
sys_init |= set(spec_dest.sys_init)
sys_safe |= set(spec_dest.sys_safety)
sys_prog |= set(spec_dest.sys_prog)
'''
sys_prog |= sys_dest_stop  # not working

# Encode the constraint that if ending point is reached, not go. And if ending point is not reached, always exist some
# robot that goes
sys_stop = set()
new_sys_nonstop = '( '
for r in range(1, num_robots + 1):
    sys_stop |= {'( ' + env_vars_list[r - 1][-1] + ' ) -> ( ' + '!go' + str(r) + ' )'}
    new_sys_nonstop += '( !' + env_vars_list[r - 1][-1] + ' ) || '
new_sys_nonstop = new_sys_nonstop[:-3] + ') -> ( '
for r in range(1, num_robots + 1):
    new_sys_nonstop += 'go' + str(r) + ' || '
new_sys_nonstop = new_sys_nonstop[:-3] + ')'
sys_stop |= {new_sys_nonstop}
sys_safe |= sys_stop  # not working

# Encode the collision avoidance constraint
sys_collision = set()  # A robot cannot go if the next position is currently occupied
for r in range(1, num_robots + 1):
    # From initial
    new_sys_collision = '( ' + 'init' + str(r) + ' && ( '
    next_pos_from_init = trajectories[r - 1][0]
    collision_possible = False
    for other_r_init in range(1, num_robots + 1):
        if other_r_init != r:
            for j in range(visit_times_all[other_r_init - 1][next_pos_from_init - 1]):
                new_sys_collision += 's' + str(other_r_init) + 'a' + str(next_pos_from_init) + 'a' + str(j + 1) + ' || '
                collision_possible = True
    if collision_possible:
        new_sys_collision = new_sys_collision[:-3] + ') ) -> !go' + str(r)
        sys_collision |= {new_sys_collision}
    # From cells to cells
    for pos_index in range(len(env_vars_list[r - 1]) - 1):
        new_sys_collision = '( ' + env_vars_list[r - 1][pos_index] + ' && ( '
        next_pos = trajectories[r - 1][pos_index + 1]
        collision_possible = False
        for other_r in range(1, num_robots + 1):
            if other_r != r:
                for j in range(visit_times_all[other_r - 1][next_pos - 1]):
                    new_sys_collision += 's' + str(other_r) + 'a' + str(next_pos) + 'a' + str(j + 1) + ' || '
                    collision_possible = True
        if collision_possible:
            new_sys_collision = new_sys_collision[:-3] + ') ) -> !go' + str(r)
            sys_collision |= {new_sys_collision}
sys_safe |= sys_collision

sys_collision_2 = set()  # If 2 robots are going to the same cell theoretically at the next timestamp,
# at least one should not go
for cell in range(1, num_cells + 1):
    for r in range(1, num_robots + 1):
        for other_r in range(r + 1, num_robots + 1):
            index_1 = -1
            for i in range(visit_times_all[r - 1][cell - 1]):
                index_1_temp = trajectories[r - 1][(index_1 + 1):].index(cell)
                index_1 += index_1_temp + 1
                index_2 = -1
                for j in range(visit_times_all[other_r - 1][cell - 1]):
                    index_2_temp = trajectories[other_r - 1][(index_2 + 1):].index(cell)
                    index_2 += index_2_temp + 1
                    if index_1 == 0:
                        new_sys_collision_2 = '( init' + str(r) + ' && '
                    else:
                        new_sys_collision_2 = '( ' + env_vars_list[r - 1][index_1 - 1] + ' && '
                    if index_2 == 0:
                        new_sys_collision_2 += 'init' + str(other_r) + ' )'
                    else:
                        new_sys_collision_2 += env_vars_list[other_r - 1][index_2 - 1] + ' )'
                    new_sys_collision_2 += ' -> (!go' + str(r) + ' || ' + '!go' + str(other_r) + ' )'
                    sys_collision_2 |= {new_sys_collision_2}
sys_safe |= sys_collision_2

# Create a GR(1) specification
specs = spec.GRSpec(env_vars, sys_vars, env_init, sys_init,
                    env_safe, sys_safe, env_prog, sys_prog)
specs.qinit = '\A \E'  # Moore initial condition synthesized too
specs.moore = False
specs.plus_one = False

print('Start synthesis')
ctrl = synth.synthesize(specs)
print('End synthesis')
assert ctrl is not None, 'unrealizable'

'''
# Generate a graphical representation of the controller for viewing
if not ctrl.save('gr1_set_1111.png'):
    print(ctrl)
machines.random_run(ctrl, N=30)
'''
